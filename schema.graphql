"""
An holder account. Can be a user or a contract
"""
type Account {
  "Account address"
  id: ID!

  "Account address"
  address: Bytes! @index

  "Balances of the account"
  balances: [TokenBalance!]! @derivedFrom(field: "account")

  "Historical changes of the account balances to retrieve balance at specific points in time"
  changes: [TokenBalanceChange!]! @derivedFrom(field: "account")
}

"""
A token is a representation of a fungible asset on the blockchain
as specified by the ERC20 standard.
"""
type Token {
  "chain - token address"
  id: ID!

  "chain id"
  chainId: Int! @index

  # metadata

  "Is virtual token, we create virtual tokens for the indexer to track non-ERC20 tokens like Beefy Boosts"
  isVirtual: Boolean!

  "The token address"
  address: Bytes! @index
  "The token symbol"
  symbol: String
  "The token name"
  name: String
  "The number of decimals the token uses"
  decimals: Int!

  ### metrics

  "The total supply of the token"
  totalSupply: BigDecimal! @config(precision: 100, scale: 24)

  "How many holders this token has. With balance > 0"
  holderCount: Int!

  # todo: handle token breakdowns

  ### references

  "The token balances of the token"
  balances: [TokenBalance!]! @derivedFrom(field: "token")
  "Historical changes of the token balance to retrieve balance at specific points in time"
  snapshots: [TokenBalanceChange!]! @derivedFrom(field: "token")
}

"""
A token balance represents the amount of a specific token that an account holds
"""
type TokenBalance {
  "chain - account address - token address"
  id: ID!

  "The chain id"
  chainId: Int! @index
  "The account that holds the token balance"
  account: Account! @index
  "The token that the account holds"
  token: Token! @index

  "Amount: the amount of the token this account holds. This amount is what is available on chain."
  amount: BigDecimal! @config(precision: 100, scale: 24)

  ### references

  "Historical changes of the token balance to retrieve balance at specific points in time"
  changes: [TokenBalanceChange!]! @derivedFrom(field: "tokenBalance")
}

"""
A balance change entity to track account balance change at specific points in time.
This enables time-travel queries since HyperIndex doesn't support them natively.
One entry is created per transfer event per account.
"""
type TokenBalanceChange {
  "Unique ID: chainId-token-account-blockNumber"
  id: ID!

  "chain id"
  chainId: Int! @index
  "Token balance reference"
  tokenBalance: TokenBalance! @index
  "Account ID reference"
  account: Account!
  "Token ID reference"
  token: Token!

  "Transaction hash of the change"
  trxHash: Bytes! @index
  "Block number of this change"
  blockNumber: BigInt! @index
  "Timestamp of this change"
  blockTimestamp: Timestamp! @index

  "Balance amount before the change"
  balanceBefore: BigDecimal! @config(precision: 100, scale: 24)
  "Balance amount at the end of the block"
  balanceAfter: BigDecimal! @config(precision: 100, scale: 24)
}

type PoolRewardedEvent {
  "chain - trx hash - log index"
  id: ID!

  "chain id"
  chainId: Int! @index
  "The trx hash"
  trxHash: Bytes! @index
  "The log index"
  logIndex: Int! @index

  "Block number of the event"
  blockNumber: BigInt! @index
  "Timestamp of the event"
  blockTimestamp: Timestamp! @index

  "The reward pool address. Can be a reward pool or a boost. Represented by the share token address"
  poolShareToken: Token! @index

  "The reward token address"
  rewardToken: Token! @index
  "The reward amount"
  rewardAmount: BigDecimal! @config(precision: 100, scale: 24)
  "The reward linear distribution duration in seconds, set to 0 for immediate distribution"
  rewardVestingSeconds: BigInt!
}

"""
The status of the contract's initialization
"""
enum InitializableStatus {
  "The contract is in the process of being initialized"
  INITIALIZING
  "The contract is able to accept deposits and earn yield"
  INITIALIZED
}

############################
###### Beefy Products ######
############################

"""
A vault is a contract that manages the assets of a Beefy product.
This entity is mostly used to start tracking the events and link them to the Beefy product on new event
"""
type ClassicVault {
  "chain - vault address"
  id: ID!

  "chain id"
  chainId: Int! @index
  "The vault address"
  address: Bytes! @index

  "The share token of the vault"
  shareToken: Token!
  "The token the vault is using as its underlying asset"
  underlyingToken: Token!

  "Initialized status"
  initializableStatus: InitializableStatus!
  "The first block the vault was active on"
  initializedBlock: BigInt!
}

"""
A strategy is a contract that manages the assets of a Beefy product.
This entity is mostly used to start tracking the events and link them to the Beefy product on new event
Also used to ignore balance changes events for this address
"""
type ClassicVaultStrategy {
  "chain - strategy address"
  id: ID!

  "chain id"
  chainId: Int! @index
  "The strategy address"
  address: Bytes! @index

  "The classic vault of the strategy"
  classicVault: ClassicVault!
}

"""
A boost is a contract that manages the assets of a Beefy product.
This entity is mostly used to start tracking the events and link them to the Beefy product on new event
"""
type ClassicBoost {
  "chain - boost address"
  id: ID!

  "chain id"
  chainId: Int! @index
  "The boost address"
  address: Bytes! @index

  "The share token of the boost, this is a virtual token"
  shareToken: Token!
  "The underlying token of the boost"
  underlyingToken: Token!

  "Initialized status"
  initializableStatus: InitializableStatus!
  "The first block the boost was active on"
  initializedBlock: BigInt!
}

"""
An adapter is a wrapping contract that allows a classic vault to be used as an ERC4626 vault.
One share of the adapter is equal to one share of the classic vault.
"""
type Erc4626Adapter {
  "chain - adapter address"
  id: ID!

  "chain id"
  chainId: Int! @index
  "The adapter address"
  address: Bytes! @index

  "The share token of the adapter, this is a virtual token"
  shareToken: Token!
  "The underlying token of the adapter"
  underlyingToken: Token!

  "Initialized status"
  initializableStatus: InitializableStatus!
  "The first block the adapter was active on"
  initializedBlock: BigInt!
}

"""
A ClmManager handles the accounting of a CLM.
"""
type ClmManager {
  "chain - manager address"
  id: ID!

  "chain id"
  chainId: Int! @index
  "The manager address"
  address: Bytes! @index

  "The share token of the manager, this is a virtual token"
  shareToken: Token!
  "The underlying tokens of the manager"
  underlyingToken0: Token!
  underlyingToken1: Token!

  "Initialized status"
  initializableStatus: InitializableStatus!
  "The first block the manager was active on"
  initializedBlock: BigInt!
}

"""
Some clm vaults do not automatically compound their earnings. Those earnings are sent to the reward pool instead.
Another use of reward pools is to boost beefy products.
This entity is mostly used to start tracking the events and link them to the Classic vault on new event
"""
type RewardPool {
  "chain - reward pool address"
  id: ID!

  "chain id"
  chainId: Int! @index
  "The reward pool address"
  address: Bytes! @index

  "The share token of the reward pool, this is a virtual token"
  shareToken: Token!
  "The underlying tokens of the reward pool"
  underlyingToken: Token!

  "Initialized status"
  initializableStatus: InitializableStatus!
  "The first block the reward pool was active on"
  initializedBlock: BigInt!
}

"""
A beefy liquid staking vault like beS.
"""
type LstVault {
  "chain - lst address"
  id: ID!

  "chain id"
  chainId: Int! @index
  "The lst address"
  address: Bytes! @index

  "The share token of the lst, this is a virtual token"
  shareToken: Token!
  "The underlying token of the lst"
  underlyingToken: Token!

  "Initialized status"
  initializableStatus: InitializableStatus!
  "The first block the lst was active on"
  initializedBlock: BigInt!
}
